# Mini-shell
Creation of a shell system where a set of basic commands have been programmed that allow communication with the computer processes, in the same way that Bash would do with the operating system.

The work has been planned according to "levels", where the level of abstraction will increase according to progress. From the basic to the most complex.

## Level 1

In this first level we will create the skeleton of our mini shell. We will have an infinite loop consisting of 2 actions: reading a command line from the terminal and executing it. In order to execute it, we will first have to decompose that line into tokens (significant elements), and analyze whether the first of them (the command in question) is an internal command (which we will implement) or an external one (whose external execution we will delegate). in a child process).

## Level 2

At this level we will implement the internal cd and export commands of our mini shell, and we will also see how to deal with the errors that system calls can produce, and in general how to use the standard error flow to display any errors in our programs.

## Level 3

At this level we will prepare our minishell so that it is capable of executing, through the execvp() system call, commands that are not internal. Every time we detect that it is an external command, the minishell (parent process) will create a child that is in charge of it.
We will also continue implementing internal commands, specifically the source and we will also be able to exit the minishell by pressing Ctrl+D.

## Level 4

At this level our mini shell (parent process) will manage various signals using its own handlers.
Specifically, it will be able to respond to the SIGINT interrupt signal, generated by the user from the keyboard by pressing Ctrl + C, causing it to abort the child process (external command) that was running in the foreground (without aborting the parent process and therefore both remaining inside the mini shell).
It will also have its own handler for the SIGCHLD signal, (we will call the handler reaper()) which will be activated automatically when such signal is generated at the end of a child. This handler will be the one who uses the waitpid() system call, informing on the screen when a child ends and with what status.
In this way, we can indicate that the parent process (the mini shell) is only waiting if there is a process running in the foreground (it will not do so for the background ones that we will create later) and it will also do so until any signal that affects it is produced (not only SIGCHLD but also SIGINT, and later it will also manage the SIGTSTP produced when the user presses the Ctrl + Z keys).


## Level 5

At this level we will manage background processes (which we will add to our jobs_list array) and we will also add the management of a new signal, the SIGTSTP (produced by pressing Ctrl + Z), which, like in the previous level, we will make the child ignore it and have the parent manage it through a handler that will send a similar signal, SIGSTOP, to the foreground process (if it exists and is not the mini shell executed within the mini shell).

In addition, we will add 1 internal command, jobs, which will allow us to obtain a list of existing jobs and their status (we will need auxiliary functions to manage the jobs_list array: add jobs, delete them, search for them...) and 2 more internal commands, fg and the bg, which will allow us to play with the reactivation of stopped processes and the transition from foreground to background and vice versa.

## Level 6

At this level our mini shell will have to allow the redirection of the output of an external command to an external file, indicating “> file” at the end of the line.


